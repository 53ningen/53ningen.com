---
slug: system-performance-326
title: システムコール、メモリ管理
category: programming
date: 2018-07-12 23:58:49
tags: [詳解システムパフォーマンス]
pinned: false
---

- [詳解システムパフォーマンス読書メモ](https://amzn.to/2CS2IUE)
  - 第３章 オペレーティングシステム　3.2.6. システムコール ~ 3.2.8 メモリ管理

## システムコール

- カーネルを単純に保つためにできるだけ少数のシステムコールに抑えるように作られている
- カーネルに対して、特権的なアクションの実行を依頼する
- システムコールを組み合わせ、ユーザーランドではより高度なインスターフェースを備えたシステムライブラリが作られている or 作ることができる
- そうしたシステムライブラリを組み合わせさらに高度なアプリケーションを作っていく
- 基本的に `man`　に全部のってるのでそこを確認して行こう
- システムコールは目的が明確でインターフェースが単純なものが多いが次のようなものが難しい
  - `inctl()`
  - `mmap()`
  - `brk()`


## メモリ管理と仮想メモリ

- 仮想メモリは、メインメモリの抽象概念
  - 物理メモリが足りないというコンピュータの問題に対して、システム実際以上のメモリがあるように見せかける仕組みとして仮想メモリというものが打ち立てられた
  - メモリ競合関係にあるプロセス間での調停をおこなう

> メモリ管理サブシステムは、オペレーティングシステムの最も重要な部分 のひとつである。コンピュータの黎明期以来、システム上にある物理メモリだけでは 足りない状況がずっと続いてきた。この限界を克服するために様々な戦略が立てられ たが、それらのうちで最も成功したのが、仮想メモリ(virtual memory)である。 仮想メモリとは、システムに実際以上のメモリがあるかのように見せる仕組みであり、 メモリ争奪関係にあるプロセス間で、必要に応じてそれらを協調して使用することに より実現されている。
> [The Linux Kernel: メモリ管理](http://archive.linux.or.jp/JF/JFdocs/The-Linux-Kernel-4.html) より

- 仮想メモリ空間は、プロセスごとに独立したアドレス空間を持つ仕組みでもあるため、データの保護という観点でも重要だ

> メモリには、物理アドレスがふられている。
> ユーザ・プロセスが実行されると、CPUは、仮想アドレス(virtual address) を 出力する。
> 仮想アドレスのうち、上位は、MMU (MMU) により変換する。
> 仮想アドレスのうち、下位(ページサイズ分)は、そのままメモリに送られる。
> [メモリ管理、アドレス空間、ページテーブル](http://www.coins.tsukuba.ac.jp/~yas/coins/os2-2011/2012-01-24/) より引用

- 複数のプロセスがメインメモリの同じ領域をアロケートすることも認める仕組みがある（共有仮想メモリ）
- 仮想メモリはプロセッサとOS双方のサポートが必要
- OS は必要に応じてメインメモリとディスクのどちらかに仮想メモリを透過的にマッピングできる
  - 仮想メモリを実メモリにマップする必要がある際にオンデマンドで行われる
- 仮想メモリによりメインメモリの大きさを超え、ディスクを利用できるようになったが、カーネルはアクティブなデータをメインメモリに残そうとする
  - メインメモリのほうが圧倒的にアクセス速度が早いため、当たり前の戦略ではある
- メインメモリにアクティブデータを残すために動作する以下の二つのカーネルルーチンが存在する
  - ページング: ページ単位でメインメモリからディスクにデータを移動する
  - スワッピング: プロセス全体のデータをディスクに移動する

> 物理メモリを節約するひとつの方法は、実行中のプログラムが現在使用している仮想ページだけをロードすることである。
> （中略）
> アクセスされた仮想ページだけ をメモリにロードするというこのテクニックは、デマンドページング(demand paging) と呼ばれる。
> プロセスが物理メモリ上にない仮想アドレスにアクセスしようとした場合、プロ セッサは、参照された仮想ページのページテーブルエントリを見つけることができな い。たとえば、 図表(3.1) では、プロセス X の ページテーブルには、仮想フレーム番号 2 のエントリがないので、プロセス X が 仮想ページフレーム番号 2 の中にあるアドレスを読もうとしても、プロセッサは、 そのアドレスを物理メモリ上のアドレスに変換できない。この時点で、プロセッサは、 ページフォルトが発生したことをオペレーティングシステムに通知する。
> [The Linux Kernel: メモリ管理](http://archive.linux.or.jp/JF/JFdocs/The-Linux-Kernel-4.html) より引用

Unix にはスワッピングしかなかったらしい。スワッピングはパフォーマンス上大きな問題だったが、プロセスのデータすべてではなく、細かく刻んだページ単位で同様の動きをするページングという仕組みにより、これを改善した。基本的に LRU のうごき。

Linuxではプロセス全体のスワップをサポートしていないため、しばしばスワッピングとページングは同じ意味で使われているらしい。なるほどー。Linux ではスワッピングの単位がページングの単位と一致しているので、同じ意味であると「Linuxのしくみ」にも書かれていた。
